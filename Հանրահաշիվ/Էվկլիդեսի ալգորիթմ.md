---
title: Էվկլիդեսի ալգորիթմ
tags:
  - հանրահաշիվ
  - ամբողջ-թվեր
  - ամենամեծ-ընդհանուր-բաժանարար
difficulty: "?"
ioi-freq: "?"
oi-freq: "?"
contributors:
  - <a href="https://codeforces.com/profile/erankyun">Համլետ Պետրոսյան</a>
---
## Ալգորիթմ
Ներկայացվելիք ալգորիթմում օգտագործված տեսությունը ներկայացված է [ամբողջ թվեր](./Ամբողջ թվեր.html) հոդվածում։

Հարկավոր է գտնել $a$ և $b$ բնական թվերի ամենամեծ ընդհանուր բաժանարարը։ Հայտնի է $\gcd(a, b) = \gcd(b,\ a\ \text{mod}\ b))$, եթե $a$ և $b$ թվերը երկուսն էլ ոչ զրոական են։ Եթե $a$ և $b$ թվերից որևէ մեկը 0 է, քանի որ 0-ն բոլոր ամբողջ թվերի վրա բաժանելիս ստացվում է 0 մնացորդ (համարում ենք, որ 0-ն բաժանվում է բոլոր ամբողջ թվերին), կվերադարձնենք ոչ զրոական անդամը։ $\gcd(0, 0)$-ն անիմաստ է մեզ համար, քանի որ բոլոր ամբողջ թվերը ընդհանուր բաժանարար են հանդիսանում։ Հնարավորինս կխուսափենք այդ արտահայտությունից։

Այս ամենը հաշվի առնելով, ձևակերպենք ալգորիթմ։

1. Ստուգենք, եթե $b = 0$, ապա վերադարձնենք $a$-ն,
2. հակառակ դեպքում հաշվենք և վերադարձնենք $\gcd(b,\ a\ \text{mod}\ b))$-ն։

Եթե փորձենք հաշվել $\gcd(0, 0)$-ն, ապա ալգորիթմը կվերադարձնի $0$: $\gcd(a, 0)$-ն կվերադարձնի $a$, իսկ $\gcd(0, b)$-ն կկանչի $\gcd(b, 0)$, որն էլ կվերադարձնի $b$:

## Իրականացում
```cpp
int gcd (int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd (b, a % b);
}
```

Օգտագործելով C++ լեզվի տերնար օպերատորը, կարող ենք գրառումը դարձնել մեկ տող․

```cpp
int gcd (int a, int b) {
    return b ? gcd (b, a % b) : a;
}
```

Նաև նույն ալգորիթմը կարող ենք գրառել առանց անդրադարձ (ռեկուրսիվ) կանչերի․

```cpp
int gcd (int a, int b) {
    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}
```

Հարկ է նշել, որ C++17 վերսիայից `<numeric>` գրադարանում իրականացված է `gcd` [ստանդարտ ֆունկցիան](https://en.cppreference.com/w/cpp/numeric/gcd): Ավելի հին վերսիաներում կա `__gcd` ֆունկցիա ներկայացված GNU GCC կոմպիլյատորներում (բացակայում է Microsoft C++ կոմպիլյատորներում)։ Մինչ `gcd` ստանդարտ ֆունկցիան գործում է այնպես ինչպես մեր ներկայացրած ալգորիթմը, `__gcd`-ն կարող է խնդիրներ առաջացնել զրոական պարամետրով կանչերի դեպքում։

## Արագագործությունը
#### Հաշվարկի տարբերակ 1
Նկատենք, որ եթե $a \geq b$, ապա $(a\ \text{mod}\ b)$-ը ամենաքիչը երկու անգամ փոքր է $a$-ից: Եթե $a \geq b$, ապա $a = kb + (a\ \text{mod}\ b),\ k \in \mathbb{N}$, քանի որ $kb \geq b > (a\ \text{mod}\ b)$, ստանում ենք $a = kb + (a\ \text{mod}\ b) > (a\ \text{mod}\ b) + (a\ \text{mod}\ b) = 2(a\ \text{mod}\ b)$: Որից էլ հետևում է, որ $(a\ \text{mod}\ b) < \frac{a}{2}$:

Նկատենք, որ սկսած երկրորդ կանչից $a > b$։ Այսինքն ամեն `gcd`-ի կանչին պարամետրերից մեծը փոքրանում է ամենաքիչը երկու անգամ։ Նկատելով, որ երկրորդ կանչի պարամետրերը փոքր են առաջին կանչի փոքրագույն պարամետրից կարող ենք պնդել, որ երկրորդ կանչից հետո արագագործությունը $O(2\log\min(a, b)) = O(\log\min(a, b))$ է, որտեղ $a$ և $b$  թվերը առաջին կանչի պարամետրերն են։ Հարկավոր է գումարել առաջին կանչի արագագործությունը նույնպես, որը ըստ ալգորիթմի կլինի $O(1)$։ Ընդհանուր կստանանք $O(1) + O(\log\min(a, b)) = O(\log\min(a, b))$:

#### Հաշվարկի տարբերակ 2
Ավելի լավ գնահատելու համար օգտվենք [Լամեի թեորեմից](https://en.wikipedia.org/wiki/Lam%C3%A9%27s_theorem): Ըստ Լամեի, $u$ և $v$ սկզբնական արժեքներով Էվկլիդեսի ալգորիթմում բաժանումների քանակը քիչ է 5 անգամ $\min(u, v)$-ի տասական ներկայացման նիշերի քանակից։ Այստեղ թեորեմի ապացույց չի ներկայացվի։

Հետաքրքիր է, որ կապ է հաստատվում Էվկլիդեսի ալգորիթմի և Ֆիբոնաչիի թվերի միջև (ներկայացված են [նշանավոր հաջորդականություններ](#) հոդվածում)։ Կարևոր դիտարկում է, որ $a > b \geq 1$ և $b < F_n$ դեպքում Էվկլիդեսի ալգորիթմը ամենաշատը կատարում է $n - 2$ կանչեր։ Ուղիղ $n - 2$ կանչ է կատարվում, երբ $a = F_n$ և $b = F_{n - 1}$։

## Ամենափոքր ընդհանուր բազմապատիկ
[Ամբողջ թվեր](./Ամբողջ թվեր.html) հոդվածից հայտնի է, որ $$\text{lcm}(a, b) = \frac{a \cdot b}{\gcd(a, b)}:$$Այս հատկությունը թույլ է տալիս հաշվել թվերի ամենափոքր ընդհանուր բազմապատիկը օգտագործելով արդեն իսկ իրականացված ամենամեծ ընդհանուր բաժանարարի ֆունկցիան․

```cpp
int lcm (int a, int b) {
    return a / gcd(a, b) * b;
}
```

Առաջինը կատարվում է թվերի բաժանում, քանի $a \cdot b$-ն կարող էր դուրս գալ հասանելի թվերի ինտերվալից (այս դեպքում `int`-ում ներկայացվող թվերի ինտերվալից)։ 

C++17 վերսիայից սկսած կա նաև համապատասխան `lcm` ստանդարտ ֆունկցիան։

## Երկուական հաշվարկ
Ճիշտ է `gcd` ֆունկցիան բավականին արագ է, բայց հատուկենտ դեպքերում հարկավոր է լինում այն էլ ավելի արագ դարձնել։ Օպտիմիզացիայի առարկա կարող է հանդիսանալ մնացորդ հաշվելու օպերատորը, որը թեև համարում ենք, որ կատարվում է $O(1)$ ժամանակում, բայց ավելի դանդաղ է քան գումարման, հանման և այլ երկուական գործողությունները։
Պարզվում է, որ հնարավոր է ձևակերպել ալգորիթմ, որը չի օգտագործում մնացորդի օպերատորը:

- Եթե երկու թվերն էլ զույգ են, ապա կարող ենք երկուսը դուրս հանել $\gcd$-ի ֆունկցիայից. $\gcd(2a, 2b)=2\gcd(a, b)$:
- Եթե թվերից միայն մեկն է զույգ, ապա նրանց ընդհանուր բաժանարարը զույգ չէ, և կարող ենք ազատվել երկուսից․ $\gcd(2a, b) = \gcd(a, b)$:
- Եթե երկու թվերն էլ կենտ են, կարող ենք մեկ թվից հանել մյուսը և հաշվել ամենամեծ ընդհանուր բաժանարարը ավելի փոքր թվերի համար․ $\gcd(a, b) = \gcd(b, a - b)$:

Օգտագործելով այս դատողությունները և որոշ GNU GCC կոմպիլյատորներում ներկայացված երկուական ֆունկցիաներ՝ իրականացնենք․

```cpp
int gcd(int a, int b) {
    if (!a || !b)
        return a | b;
    unsigned shift = __builtin_ctz(a | b);
    a >>= __builtin_ctz(a);
    do {
        b >>= __builtin_ctz(b);
        if (a > b)
            swap(a, b);
        b -= a;
    } while (b);
    return a << shift;
}
```

`__builtin_ctz` ֆունկցիան վերադարձնում է տրված թվի երկուական գրառման մեջ աջից անընդհատ զրոների քանակը։ Օրինակ՝ `__builtin_ctz(20)`-ը կվերադարձնի 2, քանի որ $20 = (10100)_2$, իսկ `__builtin_ctz(21)`-ը՝ 0, քանի որ $21 = (10101)_2$:

## Հղումներ
- [Euclidean algorithm for computing the greatest common divisor](https://cp-algorithms.com/algebra/euclid-algorithm.html)
- [Алгоритм Евклида нахождения НОД (наибольшего общего делителя)](https://e-maxx.ru/algo/euclid_algorithm)

## Խնդիրներ
շուտով